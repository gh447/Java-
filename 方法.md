
# 关于Java中的方法

## 让对象有行为（认识方法）

### 方法是什么

* 类中如果不定义方法，只定义成员变量，那么一个类就没有了功能，只是简单数据的封装。创建一个对象后，所有对这些数据的操作都要在每个用到这些数据的地方写代码

* 类通过成员变量和方法描述世界。成员变量是描述一类事物的属性，是数据，方法是描述一类事物的行为和功能，是对数据的操作

* 方法中的代码可以通过操作一个对象的成员变量，完成一个功能。

* 方法是Java中执行代码的单元，是代码的载体。所有的代码都必须属于某一个方法

* 方法就是一串语句加上数据输入this自引用和参数，执行后得到一个返回值。所以使用一个对象调用一个方法，可以叫做调佣对象的方法，也可以叫做“在这个对象上调用方法（invoke a method on an object）

* 方法不是对象的一部分，方法是类的一部分。每个对象可以给成员变量赋不同的值，但是无法让对象有不同的行为。同理无论在一个类里定义多少种方法多都不会影响创建一个对象所占用的内存

## 关于参数和返回值

* 参数和方法里的局部变量可以认为是一样的东西。只是在方法在调用之前，会用实参给参数的形参赋值

* 发生在代码块里的，就让它留在代码块里。方法执行完毕，参数和局部变量的数据就会被删除回收。就好像演草纸，作用是计算一个值，算好之后演草纸就可以扔了

* 调用一个有返回值的方法是就好像访问一个成员变量

## 关于this自引用

当参数和成员变量重名是就要使用this自指针（也叫this自引用），this是Java中的关键字，每个方法中都隐藏着一个this自引用，它指向的是调用这个方法的对象，简单来说，哪个引用调用了这个成员变量或方法this指向的就是谁。

## 封装

概念：用类定义成员变量，把操作成员变量的代码放在类里，就叫做封装。

优点：

* 可以集中管控，自己的成员变量别人不可以乱来，避免出现非法的状态，比如库存为负数

* 代码逻辑可以公用避免代码重复，修改的时候只需改一处

* 封装的好可以更好地抽象一类事物

## 方法的签名和重载

* 方法签名：方法名加依次参数类型。注意，返回值不属于方法签名，方法签名是一个方法在类中的唯一标识

* 同一个类中方法可以重名但签名不可以重复。一个类中如果定义了名字相同，签名不同的方法，就叫做方法的重载

## 重载的参数匹配规则

* 方法调用时，参数类型不必完全一样，对于数字类型的参数，实参数可以自动类型转换成形参类型即可

* 重载的特殊之处在于，参数满足自动类型转换的方法有好几个，重载的规则是按照byte，short，int，long，float ，double的顺序选择最近的去调用

## 构造方法

构造方法（constructor）是构造实例的方法

* 构造方法的方法名跟类名一致，且构造方法没有返回值，这样的方法才是构造方法
* 构造方法可以有参数，语法和规则与普通方法一样，使用时传递到new语句后的括号里
* 如果没有显示的添加一个构造方法，那么Java会默认给每个类自带一个没有返回值的构造方法
* 如果我们自己添加了类的构造方法，那么Java就不会给我们添加没有参数的构造方法，这时就不能new一个对象不传递参数了
* 所以我们一直在使用构造方法，这也是为什么创建对象时类名后面要加括号的原因
* 构造方法不能被点操作符调用，只能在使用new语句时间接调用
* 理解为什么构造方法不能有返回值，因为有返回值也没有意义，new语句永远返回的是创建出来的对象的引用

## 构造方法重载和互相调用

* 在构造方法里才能调用重载的构造方法，语法为this（实参列表）
* 构造方法不能自己调用自己，这会造成死循环
* 构造方法里调用重载的构造方法必须是在构造方法里的第一行
* 在调用重载的构造方法是不能使用成员变量。因为从语义上讲这个对象还没有初始化完成处于中间状态
* 添加了构造方法后，Java就不会添加无参数的构造方法，如果有需要的话我们可以自己添加这种构造方法

## 静态变量

* 静态变量使用static修饰符
* 静态变量如果不赋值，Java也会给他赋予其类型的初始值
* 静态变量一般使用全大写字母加下划线分割。这是一种习惯用法，如：DISCOUNT_FOR_VIP
* 所有代码都可以使用静态变量只要根据控制符的规范，这个静态变量对其可见即可，比如public的静态变量，所有代码都可以使用它，但是如果没有public控制，就只有当前包才能使用它
* 在当前类中使用静态变量是直接写静态变量名字就可以，但是在其他类中要用import static+包名+静态变量名（或者加通配符*）来引入静态变量才能直接写名字，或者写类名加“.”操作符加静态变量名来访问

## 静态方法

* 静态方法特点：只能使用参数和静态变量。换言之，就是没有this自引用的方法
* 静态方法是用static修饰符修饰的方法，静态方法的方法名没有约定俗成的全大写
* 静态方法可以访问静态变量，包括自己类的静态变量和访问修饰符允许的别的类的静态变量
* 除了没有this，静态方法和成员方法一样，也有返回值，方法名和参数
* 静态变量没有this自引用，调用时也无需引用，直接类名调用，所以它也不能直接访问成员变量
* 当然在静态方法里也可以自己创建对象或者通过参数获得对象的引用，进而调用方法和成员变量
* 静态方法只是没有this自引用的方法而已
* 使用import static引入一个静态方法，就可以直接用静态方法名访问了，我们也可以通过类名.静态方法名来访问静态变量

在当前类的静态方法中我们也可以访问其他类的静态变量，只需要用类名.静态变量名就可以，所以只要我们有权限访问，那么所有类的静态变量静态方法都是可以相互使用的。那么我们可以得出结论，虽然静态方法和静态变量都归属于某个类，但我们完全可以把类忽略掉，把所有的静态变量归总到一起，看做是整个程序的静态变量，也可以把类忽略掉，把所有静态方法归总到一起，看作整个程序的静态方法。

#### 以下是一个静态方法

```java
public static double getDisCountOnDiscount(LittleSuperMarket littleSupermarket){
    double activityDiscount = littleSupermarket.activityDiscount;
}
```

## 静态方法的重载

* 静态方法重载和普通方法一样，方法签名不同即可
* 判断调用哪个方法也是根据调用参数匹配决定的

## 了解三元操作符

* 形式：double abc = true ？“”  ：  0；三元操作符由？ ：构成，？之前是布尔变量，如果是true，则是冒号之前的值，如果是false则是冒号后面的值
* 例如：double sVipDiscount = isVIp？VIP_DISCOUNT ：1； 如果isVIP是true，那么sVipDiscount = VIP_DISCOUNT，如果isVip是false，那么sVipDiscount = 1；
  
## 静态代码块

* 静态代码块就是在代码块前面加一个static,比如：

  ```java
  static {
      BASE_DISCOUNT = 0.9;
      VIP_DISCOUNT = 0.85;
  }
  ```

  * 静态代码块里当然可以有任意合法的代码
  * 静态代码块在使用静态变量时必须在静态变量的后面
  * 静态代码块有顺序之分，是按照从上到下的顺序执行
  * 静态变量赋值是在<init>方法里面

## 方法和属性的可见修饰符

* 可见性修饰符用在类、成员方法、构造方法、静态方法和属性上，其可见性的范围是一样的
  
  * public 全局可见
  * 缺省 ：当前包可见
  * private，当前类可见

* 理解访问修饰符，不只是限制不让人使用，更是为了有规矩才成方圆。成员变量应该是private的，不需要让外部使用的方法都应该是private的
* 成员变量都应该声明为private，如果要读写成员变量，最好使用get ，set方法，这些方法应该是public的，这样做的好处是，如果有需要，可以通过代码检查每个属性值是否合法。


### String类

String类型的对象最重要的特点就是不可辨，对String类型的对象做的所有变化都是重新创建了一个String对象

#### String类比较常用的方法
* toUpperCase（）  小写字母转大写字母
* toLowerCase（）  大写字母转小写字母
* charAt（）       查看第几个字符，索引从0开始，如
  ```java
  String content = "012345678AbcDef"
  System.out.println(content.charAt(1) );//查看第2个字符
  //输出结果为  1

  ```



* substring()  字符串的截取，索引从0 开始，不包括自己，例如
  ```java
  String content = "012345678";
  System.out.println(content.substring(5));//表示从第6个数截到最后
  //输出结果为 5678

  ```

  还有第二个用法
  ```java
  String content = "0123456789";
  System.out.println(content.substring(0,5));
  //表示从第1个字符截到第6个字符，包括自己
  //输出结果为 012345
  ```

* toCharArray() 将字符打散装入数组中
  ```java
   String content = "Orange_Apple_Banana";
        //TODO 将字符串打散成一个一个的字符装入数组中
        char[] chars = content.toCharArray();
        for (int i = 0; i < chars.length; i++) {
            System.out.println(chars[i]);
        }

  ```

* split() 将字符串从参数处分割
  ```java
  String content = "Orange_Apple_Banana"
  String sp = "_";
  String [] s = content.split(sp);
  for(int i = 0;i<s.length,i++){
    System.out.println(s[i])
  }
  //输出结果为
   Orange
  Apple
  Banana

  ```


* indexOf()  查询字符第一次出现的索引，索引从0开始
  ```java
    String content = "Orange_Apple_Banana"
    System.out.println(content.indexOf('_'))
    //输出结果为6
  ```


* lastIndexOf ( ) 查询字符从后往前数第一次出现的索引，索引从0开始
  ```java
    String content = "Orange_Apple_Banana"
    System.out.println(content.lastIndexOf('_'))
    //输出的结果为12
    ```

* contains（） 查看字符串中是否包括传入的参数，区分顺序和大小写
```java
      System.out.println(content.contains("apple"));
      System.out.println(content.contains("Ap"));
      System.out.println(content.contains("Apple"));
//输出结果为 false   true   true
```

* equals () 判断传入的参数和字符串是否相同，区分大小写
* equalsIgnoreCase() 判断传入的参数和字符串是否相同，忽略大小写
* trim（）  可以将字符串开头和结尾的空格去掉

## main方法

* main方法也只是一静态的有String[]做参数的没有返回值的方法而已。它的特殊之处在于Java可以把main方法作为程序的入口

## StringBuilder
StringBuilder是一个非常方便的用来拼接和处理字符串的类，和String不同的是，它是可变的。而且对它进行操作的方法，都会返回this自引用，这样我们就可以一直点下去，对String进行构造
#### StringBuilder常用的方法
* append（） ：拼接
* reverse（）：反转
* delete（） ：删除两个索引中间的字符，包括开头，不包括结尾，索引从0开始
* insert（）：将参数插入字符串的中间，有两个参数，第一个参数是索引，第二个参数是要插入的字符串，可以把索引参数理解为字符串第一个字符在插入原字符串后的索引。
* 详见code36

# 继承
## 什么是继承
比如，在超市里卖手机，手机是商品，有着商品的属性，但手机也有自己的属性，比如cpu，运行内存，储存空间，品牌，操作系统，这时，我们在创建手机类的时候，不仅要有手机的属性，还要有商品的属性，那我们再重复的定义商品的成员变量是否就显得麻烦了呢，这时我们可以用继承，这个问题就迎刃而解
## 继承的语法和作用
### 语法：
* 在创建的类后面加上extends再加要被继承的类的名字，比如

```java
public class Phone extends Merchandise{...}

```
Phone就叫做子类（subClass），Merchandise叫做父类（parentClass）
  

  * Java只允许一个类有一个直接的父类，即所谓的单继承
  * 但是可以连续继承，比如可以再来一个HuaweiPhone来继承Phone

### 作用：
* 子类继承了父类的方法和属性
* 使用子类可以调用父类的共有方法（public的方法）
* 使用子类可以调用父类的共有属性（public的属性）
* 但是子类不能使用父类的private的方法和属性
* 就好像子类的引用即可以当父类的引用使用，也可以当子类的引用使用

## 组合
解决重复定义问题的另一个思路，组合，在Phone中定义一个Merchandise类型的引用，可以认为商品属性也是手机的一个属性，通过这种方式，我们也可以通过这个引用来调用商品类里的方法。但这个方法也有局限性，如果新增了一项需求，比如手机一次最多只能买5个，我们用组合就很难完成这个需求。

* 首先我们不能修改Merchandise类里的方法，因为这个类是所有商品的类，一旦修改其他的商品也会收到影响。
* 其次我们不能在每次调用buy方法的时候做限制，这样我们可能会面临到处改代码的情况，比如小米手机限购两个，华为手机限购3个，那么这时候就会很繁琐
* 再次我们可以在Phone类里面添加一个buyOne的方法，但是这样并不能一劳永逸的把购买数量限制死，别人还是可以通过访问Merchandise的方式来超过限制

那么现在来理清一下核心诉求，针对手机，限制一次购买的数量，必须一次限制死，不能影响别的商品，必须只修改手机类的代码，这时候，组合就无能为力了，继承可以发挥它的作用

## 继承和组合的区别
* 继承不是组合，继承也不只是为了能简单的拿来父类的属性和方法，如果仅仅如此，组合也能做到。
* 继承也不是通过组合实现的，和组合相比，继承更像是一种融合
* 继承表达的其实是一种is-a的关系，也就是说，在你用类构造的世界里，子类是父类的一种特殊类别
* 组合表达的是一种has-a的关系，是手机有商品的属性
* 在拿到一个问题，设计相应Java程序的时候，选择组合和继承使我们不得不面对的一个问题，优先使用组合，谨慎使用继承

## 覆盖（OverRide）
那么如何使用继承解决只能买5个的问题呢？用覆盖！覆盖才是继承的精髓和奥义
### 覆盖的语法
* 通过使用和父类签名一样，返回值也一样的方法，可以让子类覆盖父类的方法
* 子类不只是能够将父类的方法拿过来，而且能通过覆盖来替换掉不适合子类的方法
* 返回值必须一模一样，兼容是不可以的
* 详见code37

## Super

super是Java中的关键字，用来沟通父类和子类

* 子类对象里可以认为有一个特殊的父类对象，这个父类对象和子类对象之间通过super关键字沟通。
* 使用super可以调用父类的方法和属性


#### this和super的区别
* super是子类与父类沟通的桥梁，但并不是父类的引用
* 在有覆写的类里面，如果用this来调用方法那么会首先调用自类里的方法，所以在有覆写的子类里还是优先使用super

## 调用父类的构造方法

* 使用super调用父类的构造方法，必须是子类构造方法的第一个语句
* 可以使用表达式
* super调用构造方法，不可以使用super访问父类的属性和方法，不可以使用子类成员变量和方法
* 可以使用静态变量和方法
* 如果父类里面没有无参数的构造方法，那么子类里面就必须在构造方法第一行通过super调用一个有参数的构造方法
* 子类的构造方法一定会调一个父类的构造方法，子类如果没调，那么Java会自己帮我们调一个父类无参的构造方法，如果父类里没有无参的构造方法那么就会报错，如果一个类没有构造方法，那么Java会帮它创建一个无参的构造方法，所以父类可以没有构造方法，但是如果有了一个有参的构造方法那么在子类没有调用这个有参构造方法的时候，就必须在父类创建一个无参的构造方法
